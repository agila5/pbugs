
#' @title Run \code{WinBUGS} or \code{OpenBUGS} Models in Parallel
#'
#' @description Run \code{WinBUGS} or \code{OpenBUGS} models from your \code{R}
#'   session running parallel instances of this programs, one per chain. In this
#'   manner several cores (one per chain) are used to run the MCMC simulation of
#'   the corresponding model. Results are returned in an object of class
#'   \code{bugs} and \code{pbugs}.
#'
#' @details This function basically executes parallel calls (one per chain) to
#'   \code{\link[R2WinBUGS]{bugs}}, so it is possible to use almost all the
#'   arguments associated with those functions.
#'
#'   The idea is to minimize code adaptation from regular \code{bugs} instances.
#'   Suitable code for the \code{bugs} function should run in principle in
#'   parallel by simply calling to the \code{pbugs} function with the same
#'   arguments as the original \code{bugs} call.
#'
#'   Aditionally, it is possible to replace WinBUGS' adaptive rejection sampler
#'   (\code{DFreeARS}) by a \code{Slice} sampler to sort out some classical
#'   'Traps'. It does not work with OpenBUGS.
#'
#'   When \code{DIC == TRUE}, DIC is calculated as the mean of the DIC's
#'   returned in WinBUGS logs.
#'
#' @usage pbugs(data, inits, parameters.to.save, model.file, debug = FALSE,
#'   program = c("winbugs", "openbugs"), bugs.directory = "default", cluster =
#'   NULL, pbugs.directory = "default", slice = FALSE, OpenBUGS.pgm =
#'   "default",working.directory = NULL, clearWD = FALSE, summary.only = FALSE,
#'   ...)
#'
#' @param data List or character. Either a named list (names corresponding to
#'   variable names in the \code{model.file}) of the data for the WinBUGS model,
#'   or (which is not recommended and unsafe) a vector or list of the names of
#'   the data objects used by the model. If \code{data} is a one element
#'   character vector (such as \code{"data.txt"}), it is assumed that data have
#'   already been written to the working directory into that file, e.g. by the
#'   function \code{\link[R2WinBUGS]{bugs.data}}.
#' @param inits Function or list (length == n.chains). List with \code{n.chains}
#'   elements; each element of the list is itself a list of starting values for
#'   the WinBUGS model, or a function creating (possibly random) initial values.
#'   Alternatively, if \code{inits = NULL}, initial values are generated by
#'   WinBUGS (if possible). If \code{inits} is a character vector with
#'   \code{n.chains} elements, it is assumed that inits have already been
#'   written to the working directory into those files, e.g. by the function
#'   \code{\link[R2WinBUGS]{bugs.inits}}.
#' @param parameters.to.save Character vector of the names of the parameters to
#'   save which should be monitored.
#' @param model.file Function or character (length 1). File containing the model
#'   written in \code{WinBUGS} code. The extension can be either '\code{.bug}'
#'   or '\code{.txt}'. If the extension is '\code{.bug}' and \code{program ==
#'   "WinBUGS"}, a copy of the file with extension \code{'.txt'} will be created
#'   in the \code{pbugs()} call and removed afterwards. Note that similarly
#'   named \code{'.txt'} files will be overwritten. Alternatively,
#'   \code{model.file} can be an R function that contains a BUGS model that is
#'   written to a temporary model file (see \code{\link[base]{tempfile}}) using
#'   \code{\link[R2WinBUGS]{write.model}}.
#' @param debug Logical, default: FALSE. Open WinBUGS in debug mode. It does not
#'   work with OpenBUGS in Unix (only through Wine: \code{useWINE == TRUE}).
#' @param bugs.directory Character (length 1), default: system dependent
#'   (Unix-Windows). Directory where WinBUGS is stored.
#' @param program Character (length 1), default: winbugs. The program to use,
#'   either winbugs or openbugs.
#' @param cluster Integer (length 1), default: NULL. Number of computer cores to
#'   use. If not provided, the function will estimate them.
#' @param pbugs.directory Character (length 1). Path to the pbugs directory.
#'   Default value is "/home/user/.wine/drive_c/pbugs" on UNIX OS's and
#'   "c:/pbugs" on Windows OS.
#' @param slice Logical, default: FALSE. Should WinBUGS' adaptive rejection
#'   sampler (\code{DFreeARS}) be replaced by a \code{Slice} sampler? Useful to
#'   sort out some \code{Traps}. It does not work with OpenBUGS.
#' @param OpenBUGS.pgm Character (length 1), default: system dependent
#'   (Unix-Windows). Path to OpenBUGS binary.
#' @param working.directory Character (length 1), default: result from
#'   \code{getwd}. Working directory.
#' @param clearWD Logical, default: TRUE. Should the working directory be
#'   cleaned after simulations?
#' @param summary.only Only allowed to be equal to FALSE in \code{pbugs}.
#' @param ... Additional arguments to be passed to \code{\link[R2WinBUGS]{bugs}}
#'   function.
#'
#' @return The arguments in the returned \code{pbugs} object are the same than
#'   for any \code{\link[R2WinBUGS]{bugs}} object, plus the following:
#'   \item{exec_time}{Execution time taken by the function} \item{seed}{Seed
#'   used, for reproducible simulations} \item{n_cores}{Number of computer cores
#'   used}
#'
#' @examples
#'
#' \dontrun{
#'   library(pbugs)
#'   data(sample_df)
#'   bugs_model <- function() {
#'     for (i in 1:N) {
#'       y[i] ~ dbern(pi[i])
#'       logit(pi[i]) <- beta[1] + beta[2] * x1[i] + beta[3] * x2[i] + beta[4] * x3[i]
#'     }
#'     for (j in 1:4) {
#'       beta[j] ~ dflat()
#'     }
#'   }
#'   bugs_data <- with(sample_df, list(y = y, x1 = x1, x2 = x2, x3 = x3, N = length(y)))
#'   bugs_init <- function() list(beta = rnorm(4, sd = .5))
#'   bugs_pars <- c("beta", "pi")
#'   result    <- pbugs(data = bugs_data, inits = bugs_init, parameters.to.save = bugs_pars,
#'                      model.file = bugs_model, n.thin = 1, n.chains = 4)
#' }
#'
#' @seealso \code{\link[R2WinBUGS]{bugs}}
#'
#' @export
pbugs <- function(data, inits, parameters.to.save, model.file,
                  debug = FALSE, program = c("winbugs", "openbugs"),
                  bugs.directory = "default", cluster = NULL,
                  pbugs.directory = "default", slice = FALSE, OpenBUGS.pgm = "default",
                  working.directory = NULL, clearWD = FALSE, summary.only = FALSE, ...) {

  stopifnot(is.character(pbugs.directory))
  if (!is.null(cluster)) {
    stopifnot(is.numeric(cluster) && length(cluster) == 1)
  }
  program <- tolower(program)
  program <- match.arg(program)
  if (pbugs.directory == "default") {
    pbugs.directory <- ifelse(
      .Platform$OS.type == "unix",
      path.expand(paste0("~/.wine/drive_c/pbugs/", program)),
      paste0("c:/pbugs/", program)
    )
  }
  if (summary.only) {
    summary.only <- FALSE
    warning("Option summary.only = TRUE is not supported by pbugs.",
            "\nsummary.only has been coerced to FALSE\n")
  }
  inTempDir <- FALSE
  if (!is.null(working.directory)) {
    working.directory <- path.expand(working.directory)
  } else {
    working.directory <- tempdir()
    if (.Platform$OS.type == "unix") {
      working.directory <- gsub("//", "/", working.directory)
      Sys.chmod(working.directory, mode = "777")
      on.exit(Sys.chmod(working.directory, mode = "777"), add = TRUE)
    }
    inTempDir <- TRUE
  }
  savedWD <- getwd()
  setwd(working.directory)
  on.exit(setwd(savedWD), add = TRUE)

  i.time <- Sys.time()

  if (program == "winbugs") {
    if (bugs.directory == "default") {
      bugs.directory <- ifelse(
        .Platform$OS.type == "unix",
        path.expand("~/.wine/drive_c/Program Files/WinBUGS14"),
        "C:/Program Files/WinBUGS14"
      )
    }
    bugs.obj <- pwinbugs(
      data               = data,
      inits              = inits,
      parameters.to.save = parameters.to.save,
      model.file         = model.file,
      debug              = debug,
      bugs.directory     = bugs.directory,
      cluster            = cluster,
      pbugs.directory    = pbugs.directory,
      slice              = slice,
      working.directory  = working.directory,
      clearWD            = clearWD,
      summary.only       = summary.only,
      inTempDir          = inTempDir,
      savedWD            = savedWD,
      ...
    )
  } else {
    bugs.obj <- popenbugs(
      data               = data,
      inits              = inits,
      parameters.to.save = parameters.to.save,
      model.file         = model.file,
      OpenBUGS.pgm       = OpenBUGS.pgm,
      debug              = debug,
      pbugs.directory    = pbugs.directory,
      working.directory  = working.directory,
      clearWD            = clearWD,
      summary.only       = summary.only,
      cluster            = cluster,
      inTempDir          = inTempDir,
      savedWD            = savedWD,
      ...
    )
  }
  f.time             <- Sys.time()
  exec.time          <- f.time - i.time
  bugs.obj$exec.time <- exec.time

  return(bugs.obj)
}
