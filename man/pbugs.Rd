% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pbugs.R
\name{pbugs}
\alias{pbugs}
\title{Run WinBUGS Chains in Parallel}
\usage{
pbugs(data, inits, parameters.to.save, model.file, n.chains = 3,
  n.iter = 2000, n.burnin = floor(n.iter / 2),
  n.thin = max(1, floor(n.chains * (n.iter - n.burnin) / n.sims)),
  n.sims = 1000, bin = (n.iter - n.burnin) / n.thin,
  debug = FALSE, DIC = TRUE, digits = 5, codaPkg = FALSE,
  bugs.directory = "default", program = c("winbugs", "openbugs"),
  cluster = NULL, pbugs.directory = "default",
  working.directory = NULL, clearWD = FALSE,
  useWINE = .Platform$OS.type != "windows", WINE = "/usr/bin/wine",
  newWINE = TRUE, WINEPATH = "/usr/bin/winepath", bugs.seed = NULL,
  summary.only = FALSE, save.history = !summary.only, over.relax = FALSE)
}
\arguments{
\item{data}{List or character. Either a named list (names corresponding to
variable names in the \code{model.file}) of the data for the WinBUGS model,
or (which is not recommended and unsafe) a vector or list of the names of
the data objects used by the model. If \code{data} is a one element
character vector (such as \code{"data.txt"}), it is assumed that data have
already been written to the working directory into that file, e.g. by the
function \code{\link[R2WinBUGS]{bugs.data}}.}

\item{inits}{Function or list (length == n.chains). List with \code{n.chains}
elements; each element of the list is itself a list of starting values for
the WinBUGS model, or a function creating (possibly random) initial values.
Alternatively, if \code{inits = NULL}, initial values are generated by
WinBUGS (if possible). If \code{inits} is a character vector with
\code{n.chains} elements, it is assumed that inits have already been
written to the working directory into those files, e.g. by the function
\code{\link[R2WinBUGS]{bugs.inits}}.}

\item{parameters.to.save}{Character vector of the names of the parameters to
save which should be monitored.}

\item{model.file}{Function or character (length 1). Function or path to the
file with the WinBUGS model.}

\item{n.chains}{Integer (length 1), default: 3. Number of Markov chains.}

\item{n.iter}{Integer (length 1), default: 2000. Number of total iterations per
chain (including burn in).}

\item{n.burnin}{Integer (length 1), default: floor(n.iter / 2). Length of
burn in (number of iterations to discard at the beginning).}

\item{n.thin}{Integer (length 1), default: max(1, floor(n.chains * (n.iter -
n.burnin)/n.sims)). Thinning rate.}

\item{n.sims}{Integer (length 1), default: 1000. The approximate number of
simulations to keep after thinning.}

\item{bin}{Integer (length 1), default: (n.iter - n.burnin) / n.thin. Number
of iterations between saving of results (i.e. the coda files are saved
after each bin iterations); default is to save only at the end.}

\item{debug}{Logical, default: FALSE. Open WinBUGS in debug mode. It does not
work with OpenBUGS.}

\item{DIC}{Logical, default: TRUE. Compute deviance, pD and DIC.}

\item{digits}{Integer (length 1), default: 5. Number of significant digits
used for WinBUGS input.}

\item{codaPkg}{Logical. If FALSE (default) a bugs object is returned, if TRUE
file names of WinBUGS output are returned for easy access by the
\code{coda} package through function \code{read.bugs} (not used if
 \code{program="openbugs"}). A \code{bugs}-\code{pbugs} object can be
 converted to an \code{mcmc.list} object as used by the coda package with
 the method \code{as.mcmc.list} (for which a method is provided by R2WinBUGS).}

\item{bugs.directory}{Character (length 1), default: system dependent
(Unix-Windows). Directory where WinBUGS is stored.}

\item{program}{Character (length 1), default: winbugs. The program to use,
either winbugs or openbug. The latter makes use of function openbugs and
requires the package BRugs.}

\item{cluster}{Integer (length 1), default: NULL. Number of computer cores to
use. If not provided, the function will estimate them.}

\item{pbugs.directory}{Character (length 1). Path to the pbugs directory.
Default value is "/home/user/.wine/drive_c/.pbugs" on UNIX OS's and
"c:/.pbugs" on Windows OS.}

\item{working.directory}{Character (length 1), default: result from
\code{getwd}. Working directory.}

\item{clearWD}{Logical, default: TRUE. Should the working directory be
cleaned after simulations?}

\item{useWINE}{Logical; attempt to use the Wine emulator to run WinBUGS,
defaults to FALSE on Windows, and TRUE otherwise.}

\item{WINE}{Character, path to ‘wine’ binary file, it is tried hard (by a
guess and the utilities which and locate) to get the information
automatically if not given.}

\item{newWINE}{Logical. Use new versions of Wine that have ‘winepath’ utility.}

\item{WINEPATH}{Character, path to ‘winepath’ binary file, it is tried hard
(by a guess and the utilities which and locate) to get the information
automatically if not given.}

\item{bugs.seed}{Integer (length 1), default: NULL. Seed for reproducible
simulations.}

\item{summary.only}{Set To FALSE on \code{pbugs}.}

\item{save.history}{Logical, default: TRUE. If TRUE, only a parameter summary
for very quick analyses is given, temporary created files are not removed
in that case.}

\item{over.relax}{Logical, default: FALSE. If TRUE, over-relaxed form of
MCMC is used if available from WinBUGS.}
}
\value{
the following values are returned:
\item{n.chains}{Number of chains}
\item{n.iter}{Number of iterations}
\item{n.burnin}{Number of burn in iterations}
\item{n.thin}{Thinning rate}
\item{n.keep}{number of iterations kept per chain (equal to \code{(n.iter -
n.burnin) / n.thin})}
\item{n.sims}{number of posterior simulations (equal to \code{n.chains *
n.keep})}
\item{sims.array}{3-way array of simulation output, with dimensions n.keep,
n.chains, and length of combined parameter vector}
\item{sims.list}{list of simulated parameters:
    for each scalar parameter, a vector of length n.sims
    for each vector parameter, a 2-way array of simulations,
    for each matrix parameter, a 3-way array of simulations, etc.
    (for convenience, the \code{n.keep * n.chains} simulations in sims.matrix
    and sims.list (but NOT sims.array) have been randomly permuted)}
\item{sims.matrix}{matrix of simulation output, with \code{n.chains *
n.keep}rows and one column for each element of each saved parameter (for
convenience, the \code{n.keep * n.chains} simulations in sims.matrix and
sims.list (but NOT sims.array) have been randomly permuted)}
\item{summary}{summary statistics and convergence information for each saved
parameter.}
\item{mean}{a list of the estimated parameter means}
\item{sd}{a list of the estimated parameter standard deviations}
\item{median}{a list of the estimated parameter medians}
\item{root.short}{names of argument \code{parameters.to.save} and deviance}
\item{long.short}{indexes; programming stuff}
\item{dimension.short}{dimension of \code{indexes.short}}
\item{indexes.short}{indexes of \code{root.short}}
\item{last.values}{list of simulations from the most recent iteration; they
can be used as starting points if you wish to run WinBUGS for further
iterations}
\item{pD}{an estimate of the effective number of parameters}
\item{DIC}{\code{mean(deviance) + pD}}
\item{exec_time}{Time of function execution}
\item{seed}{Seed for reproducible simulations}
\item{n_cores}{Number of computer cores used}
}
\description{
Call WinBUGS from your R session running multiple chains
  in parallel. Results are returned in an object of class \code{bugs} and
  \code{pbugs}.
}
\details{
This function basically executes a parallel call to
  \code{\link[R2WinBUGS]{bugs}}, so it is possible to use almost all the
  arguments associated with that function (except one: summary.only is set to
  FALSE). The idea is to minimize code adaptation (by simply adding a p), so
  that you can start working without the need for a learning process.
}
\examples{

\dontrun{
  library(pbugs)
  data(sample_df)
  bugs_model <- function() {
    for (i in 1:N) {
      y[i] ~ dbern(pi[i])
      logit(pi[i]) <- beta[1] + beta[2] * x1[i] + beta[3] * x2[i] + beta[4] * x3[i]
    }
    for (j in 1:4) {
      beta[j] ~ dflat()
    }
  }
  bugs_data <- with(sample_df, list(y = y, x1 = x1, x2 = x2, x3 = x3, N = length(y)))
  bugs_init <- function() list(beta = rnorm(4, sd = .5))
  bugs_pars <- c("beta", "pi")
  result    <- pbugs(data = bugs_data, inits = bugs_init, parameters.to.save = bugs_pars,
                     model.file = bugs_model, n.thin = 1, n.chains = 4)
}

}
